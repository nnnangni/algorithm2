def f(si, sj, n, s): # n: 사용한 종이수 / s: 남은 붙일 수 있는 칸(1)
    global minV
    if s == 0:
        minV = min(minV, n)
    # 최소로 붙일 수 있는 종이 수는 4장이므로 minV가 4이면 더 이상 확인해 볼 필요 없음
    elif minV == 4:
        return
    # 가지고 있는 색종이를 다 썼는데도 남은 칸수가 있다면(if 조건에 걸리지 않았다면)
    # 더 이상 진행 할 수 없으므로 확인 할 필요가 없음
    elif sum(paper) == 0:
        return
    else:
        for i in range(si, 10):
            if i != si:
                sj = 0
            for j in range(sj, 10):
                if m[i][j] == 1: # 왼쪽 모서리로 가정
                    ni, nj = i, j + 1
                    if nj > 9:
                        ni, nj = i + 1, 0

                    for k in range(5, 0, -1): # 붙이는 색종이의 크기(5, 4, 3, 2, 1)
                        # 해당 사이즈의 종이가 남아 있고 그 종이를 붙여도 전체판의 크기를 벗어나지 않는다면
                        if paper[k] > 0 and i + k <= 10 and j + k <= 10:
                            ##### 여기부터
                            # cover 라는 변수를 이용해 해당하는 종이로 덮었을 경우
                            # 총 몇 칸이 덮어졌는지 확인한다.
                            cover = 0
                            for r in range(i, i + k):
                                cover += m[r][j:j + k].count(1)
                            ##### 여기까지

                            # 색종이는 1 위에만 붙일 수 있으므로
                            # 사용한 색종이가 덮을 수 있는 넓이(k * k) 와 cover가
                            # 같을 때만 그 색종이를 사용 할 수 있다.
                            if cover == (k * k):
                                for r in range(i, i + k):
                                    for c in range(j, j + k):
                                        # 색종이를 겹쳐서 붙일 수 없으므로 이미 붙인 곳은 0로 표시해 중복을 방지한다.
                                        m[r][c] = 0
                                paper[k] -= 1 # 해당하는 사이즈의 색종이를 한장 사용하였으므로 1을 감소시킨다.
                                # 전체 사용한 색종이는 1 증가 시켜 주고 남은 1의 칸수는 사용한 색종이의 넓이 만큼 감소시켜준다.
                                f(ni, nj, n + 1, s - k * k)
                                # 재귀에서 빠져나올 경우 다른 경우의 수를 확인하기 위해 색종이를 붙였다고 표시해줬던 곳들을
                                # 다시 1로 바꿔 다른 색종이를 붙일 수 있도록 만들어 준다.
                                for r in range(i, i + k):
                                    for c in range(j, j + k):
                                        m[r][c] = 1
                                # 붙인 색종이를 다시 떼어 냈으므로 해당 사이즈에서 사용할 수 있는 색종이의 개수도 1 증가 시켜준다.
                                paper[k] += 1
                    return

m = [list(map(int, input().split())) for _ in range(10)] # 입력 받은 값을 저장할 list
# 종이를 최대로 사용할 수 있는 경우는 25이므로 그보다 큰 수를 최소값으로 초기화 해준다
# 만약 최소값을 25로 할 경우 종이 붙이기를 불가능한 경우(-1) 을 판별할 때
# 아무것도 붙이지 못해서 최소값이 25가 남아 있는 것인지 아니면
# 정말로 25장의 종이를 다 사용한 것인지 판별 할 수 없으므로 그 보다 큰 값으로 초기화 한다.
minV = 26 # 붙일 수 있는 최소 색종이 수를 저장할 변수
s = 0 # 붙일 수 있는 칸(1)을 저장할 변수
# 색종이는 사이즈 별로 5장씩 사용 할 수 있으며 각 사이즈의 색종이를 몇 장 사용했는지 확인하기 위한 리스트
paper = [0, 5, 5, 5, 5, 5]
for i in m:
    s += i.count(1)

f(0, 0, 0, s)
if minV == 26:
    minV = -1
print(minV)